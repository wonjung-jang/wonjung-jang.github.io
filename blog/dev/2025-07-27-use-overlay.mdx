---
title: useOverlay 분석해보기.
description: toss slash 라이브러리에 있는 useOverlay를 분석한 기록입니다.
slug: 2025-07-27-use-overlay
authors: wonjung
tags: [useOverlay]
hide_table_of_contents: false
---

import ImageWrapper from "@site/src/components/ImageWrapper";

요즘 어떻게 학습해야 할지 고민이 많다.
무언가를 깊게 알아보고 싶은데, 나와 너무 동떨어진 내용이면 흥미가 안 생긴다.
그래서 책을 하나 잡고 보기에는 내 상황과 다른 게 많고 모든 내용이 와닿지 않는다.

어떻게 해야 하나 고민하던 가운데, 오픈 소스를 뜯어보자는 생각을 했다.
어떤 오픈 소스를 볼지 생각하다가 회사에서 사용하는 도구 위주로 봐야겠다고 생각했다.

처음에는 TanStack Query를 뜯어볼까 하다가 양도 많고 복잡해서 금세 흥미가 사라졌다.
그러다 toss에서 만든 useOverlay 보게 됐다.
회사에서 사용하고 있기도 하고 간단해서 덜 부담됐다.

## 1. useOverlay란?

useOverlay란 Overlay를 선언적으로 쓸 수 있게 해주는 도구다.
Overlay란 BottomSheet와 Dialog처럼 별도의 레이어에 띄우는 컴포넌트다.

<ImageWrapper
  src="/blog/dev/2025-07-27-use-overlay/image.png"
  alt="useOverlay 공식 문서에 나와있는 설명"
  width="70%"
/>

여담으로 공식 문서를 보다가 "BottomSheet과"로 되어 있는 게 어색해서 "BottomSheet와"로 바꿔 생애 첫 오픈 소스 PR을 작성했다.
한 글자 바꾼 거라 머쓱하긴 하지만 그래도 Merge 된다면 기분 좋을 듯. ㅎㅎ

## 2. 사용법

```tsx
export default function App() {
  return (
    <OverlayProvider>
      <div className="App">
        <AppContent />
      </div>
    </OverlayProvider>
  );
}
```

사용법은 간단하다.
Context API를 활용하기 때문에 Provider를 선언해 준다.

```tsx
function Dialog(props: { isOpen: boolean; onClose: VoidFunction }) {
  const { isOpen, onClose } = props;

  return isOpen ? (
    <div className="dialog-backdrop" onClick={onClose}>
      <div className="dialog-content" onClick={(e) => e.stopPropagation()}>
        <p>🧙‍♂️ 안녕하세요! 저는 다이얼로그입니다.</p>
        <button onClick={onClose}>닫기</button>
      </div>
    </div>
  ) : null;
}

function AppContent() {
  const overlay = useOverlay();
  const onClickButton = () => {
    overlay.open(({ isOpen, close }) => (
      <Dialog isOpen={isOpen} onClose={close} />
    ));
  };

  return (
    <>
      <h1>Hello CodeSandbox</h1>
      <h2>Start editing to see some magic happen!</h2>
      <button onClick={onClickButton}>다이얼로그 열기</button>
    </>
  );
}
```

사용처에서 `useOverlay`를 사용하여 버튼 클릭 시 Dialog를 열어주고, Dialog에서는 `isOpen`이 `true`일 때 렌더링되도록 한다.

## 3. OverlayProvider

먼저 `OverlayProvider`가 어떻게 되어 있는지 살펴봤다.

```ts
const [overlayById, setOverlayById] = useState<Map<string, ReactNode>>(
  new Map()
);
```

내부적으로 `overlayById`라는 상태를 관리한다.
`overlayById`는 `string` 타입의 `id`를 `key`로, `ReactNode` 타입의 `element`를 `value`로 저장한다.

```ts
const mount = useCallback((id: string, element: ReactNode) => {
  setOverlayById((overlayById) => {
    const cloned = new Map(overlayById);
    cloned.set(id, element);
    return cloned;
  });
}, []);

const unmount = useCallback((id: string) => {
  setOverlayById((overlayById) => {
    const cloned = new Map(overlayById);
    cloned.delete(id);
    return cloned;
  });
}, []);

const context = useMemo(() => ({ mount, unmount }), [mount, unmount]);
```

Provider value로 `context`를 넘겨준다.
`context`에는 overlay를 관리하는 `mount`, `unmount` 함수가 포함되어 있다.

```tsx
return (
  <OverlayContext.Provider value={context}>
    {children}
    {[...overlayById.entries()].map(([id, element]) => (
      <React.Fragment key={id}>{element}</React.Fragment>
    ))}
  </OverlayContext.Provider>
);
```

마지막으로 `children`과 `overlayById`에 저장된 모든 overlay 컴포넌트를 배치한다.
사용 예시에서 봤듯이 overlay들은 각각 내부적으로 `isOpen` 상태를 받아 true일 경우 UI를 보여주도록 해야 한다.

## 4. useOverlay

```ts
// 훅 외부
let elementId = 1;
```

`useOverlay`를 살펴보면 훅 바깥에서 `elementId` 값을 갖고 있다.
별도의 `useOverlay.tsx`로 되어있기 때문에 모듈의 특성상 캡슐화가 가능하고 외부로부터 접근을 막아서 안전하게 관리할 수 있다.

```ts
interface Options {
  exitOnUnmount?: boolean;
}

export function useOverlay({ exitOnUnmount = true }: Options = {}) {
  const context = useContext(OverlayContext);

  if (context == null) {
    throw new Error("useOverlay is only available within OverlayProvider.");
  }

  const { mount, unmount } = context;
  const [id] = useState(() => String(elementId++));

  const overlayRef = useRef<OverlayControlRef | null>(null);

  useEffect(() => {
    return () => {
      if (exitOnUnmount) {
        unmount(id);
      }
    };
  }, [exitOnUnmount, id, unmount]);

  return useMemo(
    () => ({
      open: (overlayElement: CreateOverlayElement) => {
        mount(
          id,
          <OverlayController
            // NOTE: state should be reset every time we open an overlay
            key={Date.now()}
            ref={overlayRef}
            overlayElement={overlayElement}
            onExit={() => {
              unmount(id);
            }}
          />
        );
      },
      close: () => {
        overlayRef.current?.close();
      },
      exit: () => {
        unmount(id);
      },
    }),
    [id, mount, unmount]
  );
}
```

Provider 선언 없이 사용할 때 에러를 던져주고 `open`, `close`, `exit` 메서드를 갖는 객체를 반환한다.

### 4-1. open 메서드와 OverlayController

```ts
open: (overlayElement: CreateOverlayElement) => {
  mount(
    id,
    <OverlayController
      // NOTE: state should be reset every time we open an overlay
      key={Date.now()}
      ref={overlayRef}
      overlayElement={overlayElement}
      onExit={() => {
        unmount(id);
      }}
    />
  );
},
```

`open`은 Provider로부터 받은 `mount`를 활용한다.
`mount`는 위에서 봤듯이 Provider에서 관리하는 `overlayById` 상태에 `id`와 `element`를 추가하는 함수다.

`element`를 바로 mount 하지 않고 `OverlayController`로 한 번 감싸서 `mount`해준다.

```tsx
export const OverlayController = forwardRef(function OverlayController(
  { overlayElement: OverlayElement, onExit }: Props,
  ref: Ref<OverlayControlRef>
) {
  const [isOpenOverlay, setIsOpenOverlay] = useState(false);

  // ...

  // overlayElement를 호출하면서 props 주입
  return <OverlayElement isOpen={isOpenOverlay} close={handleOverlayClose} exit={onExit} />;
}
```

`OverlayController`는 overlay의 상태 관리를 담당하는 컴포넌트다.
내부적으로 `isOpen` 상태를 관리하면서 사용자가 전달한 `element`에 `isOpen`, `close`, `exit`을 주입해 준다.

또한 `key`를 `Date.now()`로 매번 새롭게 줌으로써 overlay를 열 때마다 상태를 초기화한다.

### 4-2. close와 exit 메서드

```ts
close: () => {
  overlayRef.current?.close();
},
exit: () => {
  unmount(id);
},
```

`close`는 overlay를 닫는 메서드로 `OverlayController`의 `close` 메서드를 호출한다.

```tsx
export const OverlayController = forwardRef(function OverlayController(
  { overlayElement: OverlayElement, onExit }: Props,
  ref: Ref<OverlayControlRef>
) {
  const [isOpenOverlay, setIsOpenOverlay] = useState(false);

  const handleOverlayClose = useCallback(() => setIsOpenOverlay(false), []);

  useImperativeHandle(
    ref,
    () => {
      return { close: handleOverlayClose };
    },
    [handleOverlayClose]
  );

  useEffect(() => {
    // NOTE: requestAnimationFrame이 없으면 가끔 Open 애니메이션이 실행되지 않는다.
    requestAnimationFrame(() => {
      setIsOpenOverlay(true);
    });
  }, []);

  // overlayElement를 호출하면서 props 주입
  return <OverlayElement isOpen={isOpenOverlay} close={handleOverlayClose} exit={onExit} />;
}
```

이때 overlay는 언마운트되지 않고 `isOpen`의 상태만 `false`로 변경한다.

`exit`은 overlay를 언마운트 시키는 메서드다.
useOverlay는 기본적으로 호출한 컴포넌트가 언마운트되면 같이 언마운트 된다.
하지만 애니메이션을 넣고 싶은 경우 언마운트되면 안 되기 때문에 애니메이션을 넣을 수 없다.

`useOverlay` 호출 시 `useOverlay({ exitOnUnmount: false })`로 설정하게 되면 호출 컴포넌트가 언마운트 되더라도 overlay는 언마운트 되지 않는다.
따라서 애니메이션을 준 뒤에 exit 메서드를 실행하면 언마운트 시점을 조정할 수 있다.

코드를 뜯어보니 생각보다 복잡하지 않은 구조였다.
나는 항상 Provider 내부에서 상태와 상태 변경 함수를 모두 작성했다.

```ts
export function useOverlay({ exitOnUnmount = true }: Options = {}) {
  const context = useContext(OverlayContext);

  if (context == null) {
    throw new Error("useOverlay is only available within OverlayProvider.");
  }

  return context;
}
```

그래서 항상 위와 같은 형식으로만 사용했었는데, 코드를 보니 역할이 명확히 분리된 느낌을 받았다.
나도 다음에 Context API를 쓰면 저렇게 분리해야지.

예전에 페이지 이동 시 애니메이션을 주는 작업을 해본 경험이 있다.
애니메이션을 위해서는 언마운트 시점을 꼭 관리해 줘야 하는데, 이런 부분까지 생각하고 간단하게 할 수 있도록 `close`와 `exit`을 분리한 설계가 인상 깊었다.
